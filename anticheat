-- mb for shit explains tried my best

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local HttpService = game:GetService("HttpService")


-- configs for aggressivity below
local WEBHOOK_URL = "https://discord.com/api/webhooks/1455932382350671912/wCzOrldBQpLtcYtzELVhP__Cw77Oy1lcJ3ClkedtvNrKToHuNET0GCy5-TkEGTbf_O-W" -- webhook url used, can be any
local MAX_WALKSPEED = 20
local TELEPORT_THRESHOLD = 50 -- anything above this distance in one tick counts as a tp
local REMOTE_SPAM_LIMIT = 1 -- max remotes per second before flagging
local CHECK_INTERVAL = 0.1 -- how often we check player movement, lower = more accurate but more laggy
local BHOP_JUMP_THRESHOLD = 0.1 -- time between jumps to detect bhop scripts
local FLAGS_TO_BAN = 2 -- after it reached the amount of flags it will trigger the ban function, but for testing purposes it got removed

local playerData = {}

local function sendToDiscord(playerName, userId, reason) -- this is the function for sending the output to a discord webhook, and below is the format of the panel
	task.spawn(function()
		pcall(function()
			local data = {
				["username"] = "anticheat",
				["avatar_url"] = "https://cdn.discordapp.com/attachments/123/shield.png",
				["embeds"] = {{
					["title"] = "anticheat",
					["color"] = 16734003,
					["fields"] = {
						{["name"] = "Player", ["value"] = playerName, ["inline"] = true}, -- the username of the player
						{["name"] = "User ID", ["value"] = tostring(userId), ["inline"] = true}, -- the userid of the player
						{["name"] = "Reason", ["value"] = reason, ["inline"] = false} -- the reason they got flagged
					},
					["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%SZ"), -- gives the exact time when the user got flagged
					["footer"] = {["text"] = "cute anticheat"}
				}}
			}
			HttpService:PostAsync(WEBHOOK_URL, HttpService:JSONEncode(data), Enum.HttpContentType.ApplicationJson)
		end)
	end)
end

local function flagPlayer(player, reason) -- this is the function that flags players when getting detected by the anticheat, validating the reason then send it to the webhook and update the flag amount after
	local data = playerData[player.UserId]
	if not data then return end

	-- extract the flag type from reason string, basically gets everything before the colon
	local flagType = reason:match("^([^:]+)") or reason

	-- initialize flag counts table if it doesnt exist yet
	data.flagCounts = data.flagCounts or {}
	data.flagCounts[flagType] = (data.flagCounts[flagType] or 0) + 1

	-- send to webhook with the current flag count
	sendToDiscord(player.Name, player.UserId, reason .. " (Flag " .. data.flagCounts[flagType] .. "/" .. FLAGS_TO_BAN .. ")")
end


-- basic initializing, sets up the tables for tracking the plaayers
Players.PlayerAdded:Connect(function(player)

	playerData[player.UserId] = {
		lastPosition = nil,
		remoteCount = 0,
		lastRemoteReset = tick(),
		flagCooldowns = {}, -- prevents spam flagging the same exploit
		flagCounts = {},
		movementHistory = {}, -- stores recent movements to detect patterns
		speedViolations = 0,
		lastSpeedCheck = tick(),
		airborneHistory = {}, -- tracks what happens when theyre in the air
		lastGroundedTime = tick(),
		lastGroundedPosition = nil,
		jumpHistory = {}, -- used for bhop detection
		lastJumpTime = 0,
		strafeHistory = {},
		speedHistory = {}, -- keeps track of speed over time to catch gradual speed hacks
		positionHistory = {},
		strafePattern = {}, -- tracks jump-accelarate-land repeat cycles for strafe detection
		rapidJumpCount = 0,
		lastRapidJumpCheck = tick(),
	}

	player.CharacterAdded:Connect(function(character)
		local humanoid = character:WaitForChild("Humanoid")
		local humanoidRootPart = character:WaitForChild("HumanoidRootPart")

		-- reset everything when they respawn
		playerData[player.UserId].lastPosition = humanoidRootPart.Position
		playerData[player.UserId].flagCooldowns = {}
		playerData[player.UserId].movementHistory = {}
		playerData[player.UserId].speedViolations = 0
		playerData[player.UserId].lastSpeedCheck = tick()
		playerData[player.UserId].airborneHistory = {}
		playerData[player.UserId].lastGroundedTime = tick()
		playerData[player.UserId].lastGroundedPosition = humanoidRootPart.Position
		playerData[player.UserId].jumpHistory = {}
		playerData[player.UserId].lastJumpTime = 0
		playerData[player.UserId].strafeHistory = {}
		playerData[player.UserId].speedHistory = {}
		playerData[player.UserId].positionHistory = {}
		playerData[player.UserId].strafePattern = {}
		playerData[player.UserId].rapidJumpCount = 0
		playerData[player.UserId].lastRapidJumpCheck = tick()

		-- listen for state changes to detect jumping and stuff
		humanoid.StateChanged:Connect(function(oldState, newState)
			local data = playerData[player.UserId]
			if not data then return end

			if newState == Enum.HumanoidStateType.Jumping then
				local currentTime = tick()
				local timeSinceLastJump = currentTime - data.lastJumpTime

				table.insert(data.jumpHistory, {
					time = currentTime,
					timeSinceLastJump = timeSinceLastJump,
					position = humanoidRootPart.Position
				})

				-- keep history size reasonable, only need last 15 jumps
				if #data.jumpHistory > 15 then
					table.remove(data.jumpHistory, 1)
				end

				-- bhop detection type A - checking for super fast consecutive jumps
				if timeSinceLastJump < BHOP_JUMP_THRESHOLD and timeSinceLastJump > 0 then
					local rapidJumpCount = 0
					-- look at the last 5 jumps and count how many were rapid
					for i = #data.jumpHistory - 1, math.max(1, #data.jumpHistory - 5), -1 do
						if data.jumpHistory[i].timeSinceLastJump < BHOP_JUMP_THRESHOLD then
							rapidJumpCount = rapidJumpCount + 1
						end
					end

					if rapidJumpCount >= 3 then
						if not data.flagCooldowns.bhop or (tick() - data.flagCooldowns.bhop) > 5 then
							flagPlayer(player, "Strafe: **Type A**")
							data.flagCooldowns.bhop = tick()
						end
					end
				end

				-- strafe detection type B - looks for rhythmic jumping patterns that are too consistent
				local recentJumps = {}
				for i = #data.jumpHistory, math.max(1, #data.jumpHistory - 6), -1 do
					local jump = data.jumpHistory[i]
					if currentTime - jump.time < 2 then
						table.insert(recentJumps, jump)
					end
				end

				-- if theres 4+ jumps in 2 seconds, check if the timing is too perfect
				if #recentJumps >= 4 then
					local avgInterval = 0
					for i = 2, #recentJumps do
						avgInterval = avgInterval + (recentJumps[i-1].time - recentJumps[i].time)
					end
					avgInterval = avgInterval / (#recentJumps - 1)

					-- if average interval is between 0.15-0.5 seconds its probably scripted
					if avgInterval >= 0.15 and avgInterval <= 0.5 then
						if not data.flagCooldowns.strafeRapidJump or (tick() - data.flagCooldowns.strafeRapidJump) > 3 then
							flagPlayer(player, "Strafe: **Type B**")
							data.flagCooldowns.strafeRapidJump = tick()
						end
					end
				end

				data.lastJumpTime = currentTime

				-- record the jump phase for strafe pattern analysis
				table.insert(data.strafePattern, {
					phase = "jump",
					time = currentTime,
					position = humanoidRootPart.Position,
					velocity = humanoidRootPart.AssemblyLinearVelocity
				})
			elseif newState == Enum.HumanoidStateType.Freefall then
				-- record falling phase
				table.insert(data.strafePattern, {
					phase = "fall",
					time = tick(),
					position = humanoidRootPart.Position,
					velocity = humanoidRootPart.AssemblyLinearVelocity
				})
			elseif newState == Enum.HumanoidStateType.Landed then
				-- record landing phase
				table.insert(data.strafePattern, {
					phase = "land",
					time = tick(),
					position = humanoidRootPart.Position,
					velocity = humanoidRootPart.AssemblyLinearVelocity
				})
			end

			-- limit pattern history to last 20 entries
			if #data.strafePattern > 20 then
				table.remove(data.strafePattern, 1)
			end
		end)

		-- main movement checking loop, runs constantly to monitor player
		task.spawn(function()
			while player.Parent and character.Parent do
				task.wait(CHECK_INTERVAL)

				if not player.Parent or not character.Parent then break end

				local data = playerData[player.UserId]
				if not data then break end

				local currentPos = humanoidRootPart.Position
				local currentVelocity = humanoidRootPart.AssemblyLinearVelocity
				local isGrounded = humanoid:GetState() ~= Enum.HumanoidStateType.Freefall and humanoid:GetState() ~= Enum.HumanoidStateType.Flying

				-- raycast downwards to check if theyre actually on the ground
				local rayOrigin = currentPos
				local rayDirection = Vector3.new(0, -4, 0)
				local raycastParams = RaycastParams.new()
				raycastParams.FilterDescendantsInstances = {character}
				raycastParams.FilterType = Enum.RaycastFilterType.Exclude

				local rayResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
				local distanceToGround = rayResult and rayResult.Distance or 999
				local isActuallyGrounded = (rayResult ~= nil and distanceToGround < 3.5) or isGrounded

				-- update last grounded time and position
				if isActuallyGrounded then
					data.lastGroundedTime = tick()
					data.lastGroundedPosition = currentPos
				end

				-- speed check type C - just checking if walkspeed property is modified
				if humanoid.WalkSpeed > MAX_WALKSPEED and isActuallyGrounded then
					if not data.flagCooldowns.speed or (tick() - data.flagCooldowns.speed) > 2 then
						flagPlayer(player, "Speed Hack: **Type C**")
						data.flagCooldowns.speed = tick()
					end
				end

				if data.lastPosition then
					-- calculate different types of distance moved
					local distance = (currentPos - data.lastPosition).Magnitude
					local horizontalDistance = (Vector3.new(currentPos.X, 0, currentPos.Z) - Vector3.new(data.lastPosition.X, 0, data.lastPosition.Z)).Magnitude
					local verticalDistance = currentPos.Y - data.lastPosition.Y
					local verticalDistanceAbs = math.abs(verticalDistance)

					-- figure out which direction theyre moving in
					local movementDirection = nil
					if horizontalDistance > 0.1 then
						local horizontalMovement = Vector3.new(currentPos.X - data.lastPosition.X, 0, currentPos.Z - data.lastPosition.Z)
						movementDirection = horizontalMovement.Unit
					end

					-- store this movement in history for pattern analysis
					table.insert(data.movementHistory, {
						distance = distance,
						horizontalDistance = horizontalDistance,
						verticalDistance = verticalDistance,
						time = tick(),
						walkSpeed = humanoid.WalkSpeed,
						isGrounded = isActuallyGrounded,
						direction = movementDirection,
						velocity = currentVelocity,
						distanceToGround = distanceToGround,
						verticalVelocity = currentVelocity.Y
					})

					-- limit movement history size
					if #data.movementHistory > 10 then
						table.remove(data.movementHistory, 1)
					end

					-- store position history separately for teleport detection
					table.insert(data.positionHistory, {
						position = currentPos,
						time = tick(),
						distance = distance
					})

					if #data.positionHistory > 5 then
						table.remove(data.positionHistory, 1)
					end

					-- calculate current speed and store it
					local currentSpeed = horizontalDistance / CHECK_INTERVAL
					table.insert(data.speedHistory, {
						speed = currentSpeed,
						time = tick(),
						isGrounded = isActuallyGrounded
					})

					if #data.speedHistory > 12 then
						table.remove(data.speedHistory, 1)
					end

					-- teleport detection type A - checking for sudden massive jumps in position
					if distance > TELEPORT_THRESHOLD then
						local isSuddenJump = true

						-- ignore if theyre just falling really fast (legitimate movement)
						if verticalDistanceAbs > horizontalDistance * 1.5 and currentVelocity.Y < -40 then
							isSuddenJump = false
						end

						-- check if previous movements were normal then suddenly spiked
						if #data.positionHistory >= 3 then
							local prevDistances = {}
							for i = #data.positionHistory - 2, #data.positionHistory - 1 do
								if data.positionHistory[i] then
									table.insert(prevDistances, data.positionHistory[i].distance)
								end
							end

							local avgPrevDistance = 0
							for _, d in ipairs(prevDistances) do
								avgPrevDistance = avgPrevDistance + d
							end
							if #prevDistances > 0 then
								avgPrevDistance = avgPrevDistance / #prevDistances
							end

							-- if they were moving normally then suddenly teleported thats sus
							if avgPrevDistance < 20 and distance > TELEPORT_THRESHOLD then
								isSuddenJump = true
							end
						end

						if isSuddenJump then
							if not data.flagCooldowns.teleport or (tick() - data.flagCooldowns.teleport) > 2 then
								flagPlayer(player, "Teleport: **Type A**")
								data.flagCooldowns.teleport = tick()
							end
						end
					end
					

					-- helper function to check if speed suddenly spiked from low to high
					local function isTeleportSpike()
						if #data.speedHistory < 3 then return false end
						local recent = data.speedHistory[#data.speedHistory].speed
						local prev = data.speedHistory[#data.speedHistory - 1].speed
						
						-- if current speed is 4x max but previous was only 2x then its a spike
						if recent > (MAX_WALKSPEED * 4) and prev < (MAX_WALKSPEED * 2) then
							return true
						end
						return false
					end

					-- checks if speed went from low to high instantly and stayed high
					local function hasInstantHighSpeed()
						if #data.speedHistory < 4 then return false end
						local speeds = {}
						for i = math.max(1, #data.speedHistory - 3), #data.speedHistory do
							table.insert(speeds, data.speedHistory[i].speed)
						end
						local startedLow = speeds[1] < (MAX_WALKSPEED * 0.8)
						local jumpedHigh = speeds[2] > (MAX_WALKSPEED * 1.8)
						local staysHigh = true
						for i = 2, #speeds do
							if speeds[i] < (MAX_WALKSPEED * 1.5) then
								staysHigh = false
								break
							end
						end
						return startedLow and jumpedHigh and staysHigh
					end

					-- checks if speed increased gradually over time (more realistic for cheats that try to hide)
					local function hasGradualAcceleration()
						if #data.speedHistory < 4 then return false end
						local speeds = {}
						for i = math.max(1, #data.speedHistory - 4), #data.speedHistory do
							if data.speedHistory[i].isGrounded then
								table.insert(speeds, data.speedHistory[i].speed)
							end
						end
						if #speeds < 3 then return false end
						local hasGradualIncrease = true
						local increasingCount = 0
						for i = 2, #speeds do
							local diff = speeds[i] - speeds[i-1]

							if diff > 15 then
								hasGradualIncrease = false
								break
							end

							if diff > 2 then
								increasingCount = increasingCount + 1
							end
						end
						return hasGradualIncrease and increasingCount >= 2
					end

					-- checks if theyve been consistently moving too fast
					local function hasConsistentSpeed()
						if #data.speedHistory < 3 then return false end
						local highSpeedCount = 0
						local recentSpeeds = {}
						for i = math.max(1, #data.speedHistory - 3), #data.speedHistory do
							local record = data.speedHistory[i]
							if record.isGrounded then
								table.insert(recentSpeeds, record.speed)
								if record.speed > MAX_WALKSPEED * 1.25 then
									highSpeedCount = highSpeedCount + 1
								end
							end
						end
						return highSpeedCount >= 2 and #recentSpeeds >= 2
					end

					-- calculate max expected distance based on walkspeed with some tolerance
					local expectedMaxDistance = (humanoid.WalkSpeed * CHECK_INTERVAL * 1.35) + 1.5

					-- speed hack type B - detects gradual speed increases that stay consistent
					if horizontalDistance > expectedMaxDistance and isActuallyGrounded then
						local isSpike = isTeleportSpike()
						local hasGradual = hasGradualAcceleration()
						local consistentSpeed = hasConsistentSpeed()

						-- if speed ramped up gradually and stayed high its probably a speed hack
						if hasGradual and consistentSpeed and not isSpike then
							data.speedViolations = data.speedViolations + 1

							-- need multiple violations before flagging to avoid false positives
							if data.speedViolations >= 2 then
								if not data.flagCooldowns.speedBypass or (tick() - data.flagCooldowns.speedBypass) > 2 then
									flagPlayer(player, "Speed Hack: **Type B**")
									data.flagCooldowns.speedBypass = tick()
									data.speedViolations = 0
								end
							end
						else
							-- reset violations if movement looks normal
							if isSpike or not hasGradual then
								data.speedViolations = 0
							end
						end
					else
						-- slowly decrease violations when moving normally
						data.speedViolations = math.max(0, data.speedViolations - 0.3)
					end

					-- checks average speed over multiple movements
					if #data.movementHistory >= 4 then
						local totalHorizontal = 0
						local groundedCount = 0
						local hadAirborneMovement = false

						for _, movement in ipairs(data.movementHistory) do
							if not movement.isGrounded then
								hadAirborneMovement = true
							end
							if movement.isGrounded and movement.distance < TELEPORT_THRESHOLD then
								totalHorizontal = totalHorizontal + movement.horizontalDistance
								groundedCount = groundedCount + 1
							end
						end

						if groundedCount >= 3 then
							local avgSpeed = totalHorizontal / (groundedCount * CHECK_INTERVAL)
							local maxExpectedSpeed = MAX_WALKSPEED * 1.35 + 1.5

							local consistentSpeed = hasConsistentSpeed()
							local isSpike = isTeleportSpike()
							local hasGradual = hasGradualAcceleration()

							-- flag if average speed is too high with consistent gradual acceleration and no spikes
							if avgSpeed > maxExpectedSpeed and consistentSpeed and hasGradual and not isSpike and not hadAirborneMovement then
								if not data.flagCooldowns.avgSpeed or (tick() - data.flagCooldowns.avgSpeed) > 2.5 then
									flagPlayer(player, "Speed Hack: **Type A**")
									data.flagCooldowns.avgSpeed = tick()
								end
							end
						end
					end

					-- detects instant acceleration or sudden stops
					if #data.speedHistory >= 4 and isActuallyGrounded then
						local hasInstant = hasInstantHighSpeed()
						if hasInstant then
							local speeds = {}
							for i = math.max(1, #data.speedHistory - 5), #data.speedHistory do
								if data.speedHistory[i].isGrounded then
									table.insert(speeds, data.speedHistory[i].speed)
								end
							end
							local hasSuddenStop = false
							if #speeds >= 4 then
								local lastSpeed = speeds[#speeds]
								local prevHighCount = 0
								for i = 1, #speeds - 1 do
									if speeds[i] > MAX_WALKSPEED * 1.5 then
										prevHighCount = prevHighCount + 1
									end
								end

								if prevHighCount >= 2 and lastSpeed < MAX_WALKSPEED * 0.8 then
									hasSuddenStop = true
								end
							end
							if hasInstant or hasSuddenStop then
								if not data.flagCooldowns.speedInstant or (tick() - data.flagCooldowns.speedInstant) > 2 then
									flagPlayer(player, "Speed Hack: **Type D**")
									data.flagCooldowns.speedInstant = tick()
								end
							end
						end
					end

					-- little advanced streafe detection following my pattern
					if #data.strafePattern >= 9 then
						local completeCycles = {}
						local i = 1

						while i <= #data.strafePattern - 2 do
							local current = data.strafePattern[i]
							local next1 = data.strafePattern[i + 1]
							local next2 = data.strafePattern[i + 2]

							-- find complete cycles of jump -> fall -> land
							if current.phase == "jump" and next1.phase == "fall" and next2.phase == "land" then
								local cycleTime = next2.time - current.time
								local horizontalDist = (Vector3.new(next2.position.X, 0, next2.position.Z) - Vector3.new(current.position.X, 0, current.position.Z)).Magnitude

								-- calculate horizontal speed during jump and fall
								local jumpSpeed = Vector3.new(current.velocity.X, 0, current.velocity.Z).Magnitude
								local fallSpeed = Vector3.new(next1.velocity.X, 0, next1.velocity.Z).Magnitude
								local airAcceleration = fallSpeed - jumpSpeed

								table.insert(completeCycles, {
									time = current.time,
									cycleTime = cycleTime,
									horizontalDistance = horizontalDist,
									avgSpeed = horizontalDist / cycleTime,
									airAcceleration = airAcceleration,
									verticalChange = next2.position.Y - current.position.Y
								})

								i = i + 3
							else
								i = i + 1
							end
						end

						-- analyze the cycles to detect unnatural air acceleration
						if #completeCycles >= 2 then
							local recentCycles = {}
							local currentTime = tick()

							for _, cycle in ipairs(completeCycles) do
								if currentTime - cycle.time < 2 then
									table.insert(recentCycles, cycle)
								end
							end

							if #recentCycles >= 2 then
								local avgSpeed = 0
								local avgAcceleration = 0
								local hasAirAcceleration = false

								for _, cycle in ipairs(recentCycles) do
									avgSpeed = avgSpeed + cycle.avgSpeed
									avgAcceleration = avgAcceleration + cycle.airAcceleration

									-- if they gained more than 3 speed while in air thats not normal
									if cycle.airAcceleration > 3 then
										hasAirAcceleration = true
									end
								end

								avgSpeed = avgSpeed / #recentCycles
								avgAcceleration = avgAcceleration / #recentCycles

								-- flag if average air speed is too high and theyre accelerating mid air
								if avgSpeed > MAX_WALKSPEED * 1.4 and hasAirAcceleration and #recentCycles >= 2 then
									if not data.flagCooldowns.strafe or (tick() - data.flagCooldowns.strafe) > 3 then
										flagPlayer(player, "Strafe: **Type A**")
										data.flagCooldowns.strafe = tick()
									end
								end
							end
						end
					end

					-- additional airborne movement check for strafe
					if #data.movementHistory >= 4 then
						local timeSinceGrounded = tick() - data.lastGroundedTime

						if timeSinceGrounded < 2 then
							local airborneMovements = {}
							local totalAirSpeed = 0
							local airSpeedCount = 0

							-- collects movements in air
							for _, movement in ipairs(data.movementHistory) do
								if not movement.isGrounded then
									table.insert(airborneMovements, movement)
									local airSpeed = movement.horizontalDistance / CHECK_INTERVAL
									totalAirSpeed = totalAirSpeed + airSpeed
									airSpeedCount = airSpeedCount + 1
								end
							end

							if #airborneMovements >= 3 and airSpeedCount >= 3 then
								local avgAirSpeed = totalAirSpeed / airSpeedCount
								local airSpeeds = {}

								for _, movement in ipairs(airborneMovements) do
									table.insert(airSpeeds, movement.horizontalDistance / CHECK_INTERVAL)
								end

								-- check if speed is accelerating while in air
								local hasAcceleration = false
								if #airSpeeds >= 3 then
									for i = 2, #airSpeeds do
										if airSpeeds[i] > airSpeeds[i-1] + 3 then
											hasAcceleration = true
											break
										end
									end
								end

								-- flag if air speed is too high and accelerating
								if avgAirSpeed > MAX_WALKSPEED * 1.4 and hasAcceleration then
									if not data.flagCooldowns.strafeAir or (tick() - data.flagCooldowns.strafeAir) > 3 then
										flagPlayer(player, "Strafe: **Type A**")
										data.flagCooldowns.strafeAir = tick()
									end
								end
							end
						end
					end
				end

				data.lastPosition = currentPos

				-- fly hack detection 
				if humanoid:GetState() == Enum.HumanoidStateType.Freefall then
					if not data.freefallStart then
						data.freefallStart = tick()
						data.airborneStartPos = currentPos
					end

					local airborneTime = tick() - data.freefallStart

					if data.airborneStartPos then
						local horizontalMovement = (Vector3.new(currentPos.X, 0, currentPos.Z) - Vector3.new(data.airborneStartPos.X, 0, data.airborneStartPos.Z)).Magnitude
						local verticalMovement = currentPos.Y - data.airborneStartPos.Y

						-- records in air state
						table.insert(data.airborneHistory, {
							time = tick(),
							velocity = currentVelocity,
							horizontalMovement = horizontalMovement,
							verticalMovement = verticalMovement,
							position = currentPos,
							distanceFromGround = distanceToGround,
							verticalVelocity = currentVelocity.Y
						})

						if #data.airborneHistory > 8 then 
							table.remove(data.airborneHistory, 1)
						end
					end

					-- only check for fly after being in air for a bit
					if airborneTime > 1.5 then 
						local velocityY = currentVelocity.Y
						local velocityHorizontal = Vector3.new(currentVelocity.X, 0, currentVelocity.Z).Magnitude

						-- calculates distance from ground
						local avgDistanceFromGround = 0
						local validAirborneChecks = 0

						for _, record in ipairs(data.airborneHistory) do
							if record.distanceFromGround then
								avgDistanceFromGround = avgDistanceFromGround + record.distanceFromGround
								validAirborneChecks = validAirborneChecks + 1
							end
						end

						if validAirborneChecks > 0 then
							avgDistanceFromGround = avgDistanceFromGround / validAirborneChecks
						end

						local isClearlyAirborne = avgDistanceFromGround > 5 and distanceToGround > 4

						-- checks if velocity pattern looks like flying
						local function hasFlyPattern()
							if #data.airborneHistory < 3 then return false end

							local horizontalSpeeds = {}
							local verticalSpeeds = {}

							for _, record in ipairs(data.airborneHistory) do
								local hSpeed = Vector3.new(record.velocity.X, 0, record.velocity.Z).Magnitude
								table.insert(horizontalSpeeds, hSpeed)
								table.insert(verticalSpeeds, record.verticalVelocity)
							end

							-- calculate speeds
							local avgHSpeed = 0
							local avgVSpeed = 0
							for i = 1, #horizontalSpeeds do
								avgHSpeed = avgHSpeed + horizontalSpeeds[i]
								avgVSpeed = avgVSpeed + verticalSpeeds[i]
							end
							avgHSpeed = avgHSpeed / #horizontalSpeeds
							avgVSpeed = avgVSpeed / #verticalSpeeds

							-- check variance to see if speeds are too consistent
							local hSpeedVariance = 0
							local vSpeedVariance = 0
							for i = 1, #horizontalSpeeds do
								hSpeedVariance = hSpeedVariance + math.abs(horizontalSpeeds[i] - avgHSpeed)
								vSpeedVariance = vSpeedVariance + math.abs(verticalSpeeds[i] - avgVSpeed)
							end
							hSpeedVariance = hSpeedVariance / #horizontalSpeeds
							vSpeedVariance = vSpeedVariance / #verticalSpeeds

							-- if horizontal speed is constant and high or vertical speed is too stable its flying
							local constantHorizontal = hSpeedVariance < 5 and avgHSpeed > 12
							local constantVertical = vSpeedVariance < 3 and math.abs(avgVSpeed) < 15

							return constantHorizontal or constantVertical
						end

						local hasFly = hasFlyPattern()
						local timeSinceGrounded = tick() - data.lastGroundedTime
						local hasRecentGroundContact = timeSinceGrounded < 2

						-- checks vertical velocity anomalies
						if isClearlyAirborne and not hasRecentGroundContact then

							if velocityY > 3 or (velocityY > -8 and velocityY < 8 and airborneTime > 2) then
								if hasFly or airborneTime > 2.5 then
									if not data.flagCooldowns.flyVertical or (tick() - data.flagCooldowns.flyVertical) > 2.5 then
										flagPlayer(player, "Fly Hack: **Type A**")
										data.flagCooldowns.flyVertical = tick()
									end
								end
							end
						end

						-- analyzes horizontal movement consistency
						if #data.airborneHistory >= 4 and isClearlyAirborne then
							local avgHorizontalVel = 0
							local avgVerticalChange = 0
							local minHVel = math.huge
							local maxHVel = 0
							local verticalChanges = {}

							for i = 2, #data.airborneHistory do
								local current = data.airborneHistory[i]
								local previous = data.airborneHistory[i-1]

								local hVel = Vector3.new(current.velocity.X, 0, current.velocity.Z).Magnitude
								avgHorizontalVel = avgHorizontalVel + hVel
								minHVel = math.min(minHVel, hVel)
								maxHVel = math.max(maxHVel, hVel)

								-- track how much they move vertically between checks
								local vertChange = current.position.Y - previous.position.Y
								table.insert(verticalChanges, math.abs(vertChange))
								avgVerticalChange = avgVerticalChange + math.abs(vertChange)
							end

							avgHorizontalVel = avgHorizontalVel / (#data.airborneHistory - 1)
							avgVerticalChange = avgVerticalChange / #verticalChanges
							local hVelocityRange = maxHVel - minHVel

							-- check if horizontal movement is too consistent and fast while barely moving vertically
							local isConsistentHorizontal = hVelocityRange < 8
							local isHighHorizontalSpeed = avgHorizontalVel > 20
							local isMinimalVerticalChange = avgVerticalChange < 2

							-- flag if theyre zooming horizontally with barely any vertical movement
							if (isConsistentHorizontal and isHighHorizontalSpeed and isMinimalVerticalChange) or 
								(hasFly and avgHorizontalVel > 16 and isMinimalVerticalChange) then
								if not data.flagCooldowns.flyHorizontal or (tick() - data.flagCooldowns.flyHorizontal) > 2.5 then
									flagPlayer(player, "Fly Hack: **Type B**")
									data.flagCooldowns.flyHorizontal = tick()
								end
							end
						end

						-- extended air time check
						if airborneTime > 5 and isClearlyAirborne then

							if hasFly or math.abs(velocityY) < 10 then
								if not data.flagCooldowns.flyAirborne or (tick() - data.flagCooldowns.flyAirborne) > 3.5 then
									flagPlayer(player, "Fly Hack: **Type C**")
									data.flagCooldowns.flyAirborne = tick()
								end
							end
						end
					end
				else
					-- reset tracking when the user lands
					data.freefallStart = nil
					data.airborneStartPos = nil
					data.airborneHistory = {}
				end
			end
		end)
	end)
end)

-- cleanup player data when they leave
Players.PlayerRemoving:Connect(function(player)
	playerData[player.UserId] = nil
end)

-- this detects spam calls towards remoteevents or removefunctions
local testRemote = ReplicatedStorage:WaitForChild("TestRemote")
testRemote.OnServerEvent:Connect(function(player, ...)
	local data = playerData[player.UserId]
	if not data then return end

	-- reset counter every second
	if tick() - data.lastRemoteReset >= 1 then
		data.remoteCount = 0
		data.lastRemoteReset = tick()
	end

	data.remoteCount = data.remoteCount + 1

	-- flag if they exceeded the limit
	if data.remoteCount > REMOTE_SPAM_LIMIT then
		if not data.flagCooldowns.remoteSpam or (tick() - data.flagCooldowns.remoteSpam) > 5 then
			flagPlayer(player, "Remote spam detected (" .. data.remoteCount .. " calls/sec)")
			data.flagCooldowns.remoteSpam = tick()
		end
	end
end)
